{"version":3,"file":"main.c630eb655982726dde1e.bundle.js","sources":["webpack:///./README.md"],"sourcesContent":["module.exports = \"# React Decision Tree\\n\\n## Quick start\\n\\n`yarn add react-decision-tree-flow`\\n\\n[Demo](https://rjerue.github.io/react-decision-tree-flow)\\n\\ncode\\n\\n```\\nimport { Wizard, Step, Controls } from \\\"react-decision-tree-flow\\\";\\n\\nconst tree = {\\n  step1: [\\\"step2\\\"],\\n  step2: [\\\"step3\\\", \\\"error\\\"],\\n  step3: [\\\"step1\\\"],\\n  error: [\\\"step2\\\"]\\n};\\n\\nconst App = () => (\\n  <Wizard tree={tree} first=\\\"step1\\\">\\n    <Step name=\\\"step1\\\">\\n      <div>\\n        I am step 1\\n        <br />\\n        <Controls>\\n          {({ step2 }) => <div onClick={step2}>Go to Step 2</div>}\\n        </Controls>\\n      </div>\\n    </Step>\\n    <Step name=\\\"step2\\\">\\n      <div>\\n        I am step 2\\n        <br />\\n        <Controls>\\n          {({ step3, error }) => (\\n            <div>\\n              <div onClick={error}>Go to error</div>\\n              <div onClick={step3}>Go to Step 3</div>\\n            </div>\\n          )}\\n        </Controls>\\n      </div>\\n    </Step>\\n    <Step name=\\\"step3\\\">\\n      <div>\\n        I am step 3\\n        <br />\\n        <Controls>\\n          {({ step1 }) => <div onClick={step1}>Go to Step 1</div>}\\n        </Controls>\\n      </div>\\n    </Step>\\n    <Step name=\\\"error\\\">\\n      <div>\\n        I am step 4\\n        <br />\\n        <Controls>\\n          {({ step2 }) => <div onClick={step2}>Go to Step 2</div>}\\n        </Controls>\\n      </div>\\n    </Step>\\n  </Wizard>\\n);\\n\\n```\\n\\n## Why?\\n\\nOften times when looking for libraries to handle decision trees or wizards, I found plenty of libraries that were sequential; things that went in a nice step by step sequence.\\n\\nSadly, this isn't how things often work; total web of lies! Instead, things look more like a web such as this:\\n\\n![Process Diagram](https://i.imgur.com/43ZaQL5.png)\\n\\nThat's not a line, that's a tree. As such, I've created a declarative decision tree.\\n\\n## How?\\n\\nThere's three components to `react-decision-tree-flow` The **Wizard**, a **Step**, and **Controls**. Controls may also be exposed as a `useControls` hook.\\n\\n## Wizard\\n\\nThe Wizard needs to wrap everything because this is where the context lives. It needs two props: the **tree** and the **first** step. The wizard has an optional third prop called `middleware` for middleware that runs after each step. You pay pass in a function or an array of functions. There is a `noFirst` prop to skip running middleware on the first step. The `middleware` function takes in the params `step, setStep, tree`. `Step` is the current step, `setStep` is a function to change the step (pass in new step), and `tree` is the tree passed into the wizard.\\n\\n#### Tree\\n\\nThe tree is an object, it's keys are the steps in the wizard. Each key's value is an array to the other steps in the Wizard. Alternatively, you may input an object into the key and it will alias the value in that object. Here's an example Tree:\\n\\n```\\nconst tree = {\\n  step1: [\\\"step2\\\", \\\"sideshow\\\"],\\n  sideshow: [\\\"step3\\\", { previous: \\\"step2\\\" }],\\n  step2: [\\\"step3\\\", \\\"error\\\"],\\n  step3: [\\\"step1\\\"],\\n  error: [\\\"step2\\\"]\\n};\\n```\\n\\n- Step 1 goes to step 2 or sideshow\\n- Sideshow goes to step3 by a call to `step3()`. It can return to step2 with a call to `previous()`. More on this later.\\n- Step 2 brings you to step 3, or the error step\\n- Step 3 brings you to step 1\\n- Error brings you to step 2\\n\\n#### First\\n\\nThis one is pretty easy, it's just what the first step of the tree is. In the above example you'd just have the prop passed down as `first=\\\"step1\\\"` to start at step1\\n\\n## Step\\n\\nSteps are what make up elements in the Wizard. They have one prop: a **name**.\\n\\n#### Name\\n\\nThis is just the name of the step. It needs to line up with some value in the `tree`'s keys.\\n\\n#### Rendering Steps\\n\\nThis will be the step that is currently active\\n\\n## Controls\\n\\nThe controls are the fun part, they're how the steps get changed. The Controls just have a render prop in the children that exposes whatever you inputted into the tree. Step 1 for example would expose `step2()` and `sideshow()` that you could then call whenever you wanted. Keys may be aliased as objects too as demonstrated in the above example. The `tree` and current `step` are also exposed.\\n\\n## Hooks\\n\\nThe `useControls` hook is useful to get the controls anywhere while in a Wizard's context. It may be used as a subsititue to `Controls` and exposes the same things.\\n\\n## Wow! How dare you make this opinionated\\n\\nI even expose the `WizardContext` so you can progromatically break it and ignore my opions. It contains the following:\\n\\n```\\n{\\n  tree: {}, // the tree object\\n  step: null, // the step that the wizard is on\\n}\\n```\\n\\nThere's also a `useWizardContext` hook that exposes everything in the Wizard's context object.\""],"mappings":"AAAA","sourceRoot":""}